#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Project Euler Problem 108:

In the following equation x, y, and n are positive integers.

1/x + 1/y = 1/n

For n = 4 there are exactly three distinct solutions:

1/5 + 1/20 = 1/4
1/6 + 1/12 = 1/4
1/8 + 1/8 = 1/4

What is the least value of n for which the number of distinct solutions exceeds one-thousand?
"""

# Analysis of the equation:
# 1/x + 1/y = 1/n
# y/xy + x/xy = 1/n
# (x + y)/xy = 1/n
# xy/(x + y) = n
# xy = nx + ny
# x(y - n) = ny
# x = ny/(y - n)
# Thus a solution is generated when y - n divides ny for a given n
# Also, note that x >= y > n > 0 to generate distinct solutions
# The first solution is generated by y = n + 1, undefined for y <= n
# The last distinct solution is generated by x = y = 2n, 0 < x < 1 for y > 2n
# Thus, any solution will be of the form y = n + a, where a is a positive integer from 1 to n
# In this general case, x = n(n + a)/(n + a - n) = n^2/a + n
# Thus x is an integer when a divides n^2 for 1 <= a <= n
# Since each factor f_1 < n^2 has a corresponding factor f_2 = n^2/f_1, and n is between the two factor "halves",
#  the number of divisors from 1 to n (the number of solutions) is the (total number of divisors + 1) / 2
# As well, the total number of divisors of n is the product of the exponents on the prime factors of n, each plus one
# (http://primes.utm.edu/glossary/page.php?sort=Tau)

# This solution based on this runs in ~6.5 minutes
# Using sympy.ntheory.count_divisors it runs in ~30 seconds, but ehhh

from itertools import count
from math import sqrt
from collections import Counter
from functools import reduce
import operator

memoized_factors = {}
def prime_factors(n):
  if n not in memoized_factors:
    for divisor in range(2, int(sqrt(n)) + 1):
      other, remainder = divmod(n, divisor)
      if remainder == 0:
        memoized_factors[n] = prime_factors(divisor) + prime_factors(other)
        break
    else:
      memoized_factors[n] = Counter({n: 1})
  return memoized_factors[n]

increment = lambda x: x + 1
def num_divisors(n):
  return reduce(operator.mul, map(increment, prime_factors(n).values()))

def twice_num_solutions_minus_one(n):
  return num_divisors(n**2)

# 1999 = 2*(1000) - 1
print(next(n for n in count(3) if twice_num_solutions_minus_one(n) > 1999))
